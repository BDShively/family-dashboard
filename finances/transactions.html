<!-- /family-dashboard/finances/transactions.html -->
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Finances · Transactions</title>
<link rel="stylesheet" href="/family-dashboard/css/base.css"/>
<style>
:root{--bg:#0b1220;--card:#111832;--muted:#9db1d1;--fg:#e6eefc;--line:#2b325a}
*{box-sizing:border-box}body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,Inter}
a{color:inherit;text-decoration:none}
header{display:flex;justify-content:space-between;align-items:center;padding:16px}
.btn{background:#0f1330;border:1px solid var(--line);color:#fff;padding:8px 12px;border-radius:10px;cursor:pointer;text-decoration:none}
.btn.danger{background:#2b0f14;border-color:#5a2b2b}
.btn.ghost{background:transparent;border:1px dashed var(--line);color:#9db1d1}
.badge{padding:2px 8px;background:#0e1430;border:1px solid var(--line);border-radius:999px}
.card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:12px;margin:12px}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.grid{display:grid;gap:10px}
input,select,textarea{background:#0f1330;color:#e6eefc;border:1px solid var(--line);border-radius:10px;padding:8px}
.table{width:100%;border-collapse:collapse}
.table th,.table td{padding:8px 10px;border-bottom:1px solid var(--line);text-align:left;vertical-align:top}
.table th{color:var(--muted)}
.right{text-align:right}
.small{font-size:12px;color:var(--muted)}
.tag{padding:2px 6px;border:1px solid var(--line);border-radius:8px;background:#0f1330;font-size:12px;color:var(--muted)}
.kv{display:grid;grid-template-columns:repeat(6,minmax(150px,1fr));gap:10px}
.toast{display:none;margin:0 12px;padding:8px 10px;border-radius:10px}
.toast.ok{display:block;background:#0f2a1a;border:1px solid #2f6e4a;color:#d9ffea}
.toast.err{display:block;background:#2a0f12;border:1px solid #6a2b2b;color:#ffd6d6}
.runbox{padding:8px 10px;border:1px solid var(--line);border-radius:10px;background:#0f1330}
.bad{color:#ffb4b4}
.good{color:#a7ffcf}
.mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
</style>
</head>
<body>
<header>
  <div class="row">
    <a class="btn" href="/family-dashboard/finances/index.html">&larr; Finances</a>
    <span class="badge">Transactions</span>
  </div>
  <div id="auth"></div>
</header>

<div id="toast" class="toast"></div>

<!-- Accounts -->
<div class="card">
  <div class="row" style="justify-content:space-between">
    <div class="row">
      <strong>Accounts</strong>
      <button id="acctNew" class="btn">+ New</button>
    </div>
    <div class="row small">
      <span class="tag">Set a Starting Balance; running balance = starting + month txns.</span>
    </div>
  </div>
  <div id="acctForm" class="row" style="display:none;margin-top:8px">
    <input id="af_name" placeholder="Name (e.g., NFCU Checking)">
    <select id="af_type">
      <option>Checking</option><option>Savings</option><option>Credit Card</option>
      <option>Loan</option><option>Cash</option><option>Other</option>
    </select>
    <input id="af_start" placeholder="Starting Balance (e.g., 1200.00)">
    <input id="af_notes" placeholder="Notes" style="min-width:260px">
    <button id="af_save" class="btn">Save</button>
    <button id="af_cancel" class="btn">Cancel</button>
  </div>
  <table class="table" style="margin-top:8px">
    <thead><tr><th>Name</th><th>Type</th><th class="right">Starting</th><th>Notes</th><th class="right">Actions</th></tr></thead>
    <tbody id="acctRows"></tbody>
  </table>
</div>

<!-- Filters + Generate -->
<div class="card">
  <div class="row" style="justify-content:space-between">
    <div class="row">
      <label>Month <input id="month" type="month"></label>
      <label>Account
        <select id="filterAcct"><option value="all">All</option></select>
      </label>
      <label>Status
        <select id="filterCleared">
          <option value="all">All</option>
          <option value="uncleared">Uncleared</option>
          <option value="cleared">Cleared</option>
        </select>
      </label>
      <label>Search <input id="search" placeholder="payee, notes, category"></label>
      <button id="exportCsv" class="btn">Export CSV</button>
      <span id="counts" class="tag">—</span>
    </div>
    <div class="row">
      <button id="genDebtMins" class="btn">Generate Debt Minimums</button>
      <button id="diagDebt" class="btn ghost">Debt Min Diagnostics</button>
    </div>
  </div>
  <div class="small">Reads <code>fin_debts_accounts</code> (Min, Due Day, Pay From) → creates <code>fin_txns</code> for this month if missing.</div>
</div>

<!-- Diagnostics -->
<div class="card" id="diagCard" style="display:none">
  <div class="row" style="justify-content:space-between">
    <strong>Debt Minimum Readiness</strong>
    <span class="small">Month: <span class="mono" id="diagMonth"></span></span>
  </div>
  <table class="table" style="margin-top:8px">
    <thead>
      <tr>
        <th>Debt</th><th>Min</th><th>Due Day</th><th>Pay From</th><th>Proposed Date</th><th>Status</th><th class="right">Action</th>
      </tr>
    </thead>
    <tbody id="diagRows"></tbody>
  </table>
</div>

<!-- New / Edit Transaction -->
<div class="card" id="txCard">
  <div class="row" style="justify-content:space-between">
    <strong id="txTitle">New Transaction</strong>
    <div class="row">
      <button id="txSave" class="btn">Save</button>
      <button id="txCancelEdit" class="btn ghost" style="display:none">Cancel Edit</button>
      <button id="txClear" class="btn">Reset</button>
    </div>
  </div>
  <div class="kv" style="margin-top:8px">
    <label><span class="small">Type</span>
      <select id="t_type">
        <option value="expense">Expense</option>
        <option value="income">Income</option>
        <option value="transfer">Transfer</option>
      </select>
    </label>
    <label><span class="small">Date</span><input id="t_date" type="date"></label>
    <label id="accFromWrap"><span class="small">Account</span>
      <select id="t_account"></select>
    </label>
    <label id="accToWrap" style="display:none"><span class="small">To Account</span>
      <select id="t_accountTo"></select>
    </label>
    <label><span class="small">Amount</span><input id="t_amount" placeholder="0.00"></label>
    <label><span class="small">Category</span><input id="t_cat" placeholder="Groceries / Paycheck / ..."></label>
    <label style="grid-column:1/-1"><span class="small">Payee / Notes</span><input id="t_notes" placeholder="Who/what, memo"></label>
    <label class="row"><input id="t_cleared" type="checkbox"> <span class="small">Cleared</span></label>
  </div>
</div>

<!-- Transactions -->
<div class="card">
  <div class="row" style="justify-content:space-between">
    <div class="row">
      <strong>Transactions</strong>
      <span id="runBox" class="runbox">Running Balance: <b id="running">$0.00</b></span>
    </div>
    <div class="small">Collection: <code>fin_txns</code> · Accounts: <code>fin_accounts</code></div>
  </div>
  <table class="table" style="margin-top:8px">
    <thead>
      <tr>
        <th>Date</th><th>Type</th><th>Account</th><th>Category / Transfer</th>
        <th class="right">Amount</th><th>Cleared</th><th>Notes</th><th class="right">Actions</th>
      </tr>
    </thead>
    <tbody id="rows"></tbody>
  </table>
</div>

<script type="module">
import { onAuthStateChanged, auth, signOutUser, db } from "/family-dashboard/js/firebase-init.js";
import {
  collection, addDoc, updateDoc, deleteDoc, doc, serverTimestamp,
  getDocs, query, where, orderBy
} from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

const LOGIN="/family-dashboard/main/index.html";
const $=s=>document.querySelector(s);

function toast(msg, ok=false){
  const el=$("#toast");
  el.textContent=msg||"";
  el.className = msg ? "toast " + (ok? "ok":"err") : "toast";
}

const state={ user:null, accts:[], txns:[], editTxnId:null, payFromMap:{} };

/* Helpers */
function localISO(d=new Date()){const tz=d.getTimezoneOffset()*60000;return new Date(d.getTime()-tz).toISOString().slice(0,10);}
function todayISO(){return localISO();}
function yyyymm(d){return localISO(d).slice(0,7);}
function ymdFromMonthDay(monthStr, dayNum){
  const [y,m]=monthStr.split("-").map(n=>+n||0);
  const last = new Date(y, m, 0).getDate();
  const d = Math.min(Math.max(1, dayNum||0), last);
  return localISO(new Date(y, m-1, d));
}
function money(n){const x=Number(n)||0;return (x<0? "-$":"$")+Math.abs(x).toFixed(2);}
function parseAmt(v){return Number(String(v||"").replace(/[\$,]/g,""))||0;}
function esc(s){return String(s||"").replace(/[&<>"']/g,m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m]));}
function num(v){ const n = Number(String(v??"").replace(/[\$,]/g,"").trim()); return Number.isFinite(n)? n : 0; }

onAuthStateChanged(auth,(u)=>{
  if(!u){ location.href=LOGIN; return; }
  state.user=u;
  $("#auth").innerHTML=`<span class="badge">${u.email}</span> <a class="btn" href="#" id="so">Sign out</a>`;
  $("#so").onclick=e=>{e.preventDefault();signOutUser();};

  init();
});

function init(){
  $("#month").value=yyyymm(new Date());
  $("#month").onchange=()=>{ loadTxns(); if($("#diagCard").style.display!=="none"){ runDiagnostics(); } };
  $("#filterAcct").onchange=render;
  $("#filterCleared").onchange=render;
  $("#search").oninput=render;
  $("#exportCsv").onclick=exportCsv;

  // accounts ui
  $("#acctNew").onclick=()=>openAcctForm();
  $("#af_cancel").onclick=closeAcctForm;
  $("#af_save").onclick=saveAcct;

  // transaction ui
  $("#t_date").value=todayISO();
  $("#t_type").onchange=toggleTransfer;
  $("#txSave").onclick=saveTxn;
  $("#txClear").onclick=resetTxnForm;
  $("#txCancelEdit").onclick=exitEditMode;

  // debt gen + diagnostics
  $("#genDebtMins").onclick=generateDebtMinimums;
  $("#diagDebt").onclick=()=>{ const on = $("#diagCard").style.display!=="none"; $("#diagCard").style.display = on?"none":"block"; if(!on) runDiagnostics(); };

  Promise.all([loadAccountsForFilters(), loadTxns()]);
}

async function loadAccountsForFilters(){
  const snap=await getDocs(query(collection(db,"fin_accounts"), where("owner","==",state.user.email)));
  const list = snap.docs.map(d=>({id:d.id,...d.data()}));
  state.accts = list.sort((a,b)=>String(a.name||"").localeCompare(String(b.name||"")));
  // map for diagnostics
  state.payFromMap = Object.fromEntries(state.accts.map(a=>[a.id, a.name]));
  renderAcctFilters();
  renderTxnAcctSelects();
}

/* ACCOUNTS CRUD (bank/credit accounts, not debts) */
function renderAcctFilters(){
  const sel=$("#filterAcct"); sel.innerHTML='<option value="all">All</option>';
  state.accts.forEach(a=>{ const o=document.createElement("option"); o.value=a.id; o.textContent=a.name; sel.appendChild(o); });
}

function renderTxnAcctSelects(){
  const from=$("#t_account"), to=$("#t_accountTo");
  from.innerHTML=""; to.innerHTML="";
  state.accts.forEach(a=>{
    const o1=document.createElement("option"); o1.value=a.id; o1.textContent=a.name; from.appendChild(o1);
    const o2=document.createElement("option"); o2.value=a.id; o2.textContent=a.name; to.appendChild(o2);
  });
}

function openAcctForm(a=null){
  // simple inline creator for fin_accounts
  $("#acctForm").style.display="flex";
  $("#af_name").value=a?.name||"";
  $("#af_type").value=a?.type||"Checking";
  $("#af_start").value=a?.startingBalance??"";
  $("#af_notes").value=a?.notes||"";
}
function closeAcctForm(){ $("#acctForm").style.display="none"; }
async function saveAcct(){
  try{
    const payload={
      owner: state.user.email,
      name: $("#af_name").value.trim(),
      type: $("#af_type").value,
      startingBalance: $("#af_start").value===""? 0: parseAmt($("#af_start").value),
      notes: $("#af_notes").value.trim(),
      createdAt: serverTimestamp(), updatedAt: serverTimestamp()
    };
    if(!payload.name){ toast("Account name required."); return; }
    await addDoc(collection(db,"fin_accounts"),payload);
    closeAcctForm();
    await loadAccountsForFilters();
    toast("Account saved", true);
  }catch(e){ toast(e.message||String(e)); }
}

/* TRANSACTIONS */
function toggleTransfer(){
  const t=$("#t_type").value;
  $("#accToWrap").style.display = t==="transfer" ? "block":"none";
  $("#accFromWrap").querySelector("span").textContent = t==="transfer" ? "From Account":"Account";
}

function resetTxnForm(){
  state.editTxnId=null;
  $("#txTitle").textContent="New Transaction";
  $("#txSave").textContent="Save";
  $("#txCancelEdit").style.display="none";

  $("#t_type").value="expense"; toggleTransfer();
  $("#t_date").value=todayISO();
  $("#t_account").selectedIndex=0;
  $("#t_accountTo").selectedIndex=0;
  $("#t_amount").value="";
  $("#t_cat").value="";
  $("#t_notes").value="";
  $("#t_cleared").checked=false;
}

function exitEditMode(){
  resetTxnForm();
  toast("Edit cancelled", true);
}

async function loadTxns(){
  try{
    toast("");
    const month=$("#month").value;
    let txDocs=[];
    try{
      const snap=await getDocs(query(
        collection(db,"fin_txns"),
        where("owner","==",state.user.email),
        where("month","==",month),
        orderBy("date","asc"), orderBy("createdAt","asc")
      ));
      txDocs=snap.docs;
    }catch{
      const snap=await getDocs(query(
        collection(db,"fin_txns"),
        where("owner","==",state.user.email)
      ));
      txDocs = snap.docs.filter(d=>(d.data().month===month));
      txDocs.sort((a,b)=>{
        const da=(a.data().date||""), db=(b.data().date||"");
        if(da===db){ return (a.data().createdAt?.seconds||0)-(b.data().createdAt?.seconds||0); }
        return da<db? -1: 1;
      });
      toast("Using fallback (add composite index for fin_txns).", true);
    }
    state.txns=txDocs.map(d=>({id:d.id,...d.data()}));
    render();
  }catch(e){ toast(e.message||String(e)); }
}

async function saveTxn(){
  try{
    const type=$("#t_type").value;
    const date=$("#t_date").value || todayISO();
    const month=date.slice(0,7);
    const accountId=$("#t_account").value || null;
    const accountIdTo=$("#t_accountTo").value || null;
    const amount=parseAmt($("#t_amount").value);
    const category=$("#t_cat").value.trim();
    const notes=$("#t_notes").value.trim();
    const cleared=$("#t_cleared").checked;

    if(type!=="transfer" && !accountId){ toast("Select an account."); return; }
    if(type==="transfer" && (!accountId || !accountIdTo || accountId===accountIdTo)){ toast("Select two different accounts."); return; }
    if(!amount || amount<=0){ toast("Enter a positive amount."); return; }

    const payload={
      owner: state.user.email, type, date, month, accountId,
      accountIdTo: type==="transfer"? accountIdTo:null,
      amount, category: type==="transfer"? "Transfer": category|| (type==="income"?"Income":"Expense"),
      notes, cleared, updatedAt: serverTimestamp()
    };

    if(state.editTxnId){
      await updateDoc(doc(db,"fin_txns",state.editTxnId), payload);
      toast("Transaction updated", true);
    }else{
      await addDoc(collection(db,"fin_txns"), { ...payload, createdAt: serverTimestamp() });
      toast("Transaction saved", true);
    }

    resetTxnForm();
    await loadTxns();
  }catch(e){ toast(e.message||String(e)); }
}

/* Generate debt minimums into fin_txns */
async function generateDebtMinimums(){
  try{
    const month=$("#month").value;
    const debts = await loadDebts();
    if(!debts.length){ toast("No debts found.", false); return; }

    // Existing for month
    const tsnap = await getDocs(query(
      collection(db,"fin_txns"),
      where("owner","==",state.user.email),
      where("month","==",month)
    ));
    const existing = tsnap.docs.map(d=>({id:d.id, ...d.data()}));

    let created=0, skippedMissing=0, skippedDup=0;
    for(const d of debts){
      const {ok, reason, min, dueDay, acctId, date} = debtReady(d, month);
      if(!ok){ skippedMissing++; continue; }

      // duplicate if same month & exact debtAccountId OR same acct+date+amount+category prefix
      const dup = existing.find(x =>
        x.type==="expense" && x.month===month &&
        (x.debtAccountId===d.id ||
         (x.accountId===acctId && x.date===date && num(x.amount)===min &&
          String(x.category||"").startsWith("Debt Min:")))
      );
      if(dup){ skippedDup++; continue; }

      const cat   = `Debt Min: ${d.name||"Account"}`;
      const notes = d.lender ? `Auto-generated min for ${d.lender}` : `Auto-generated min`;

      await addDoc(collection(db,"fin_txns"),{
        owner: state.user.email,
        type: "expense",
        date, month,
        accountId: acctId,
        accountIdTo: null,
        amount: min,
        category: cat,
        notes,
        cleared: false,
        debtAccountId: d.id,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      });
      created++;
    }

    await loadTxns();
    toast(`Debt minimums — created: ${created}, skipped(missing): ${skippedMissing}, skipped(dups): ${skippedDup}`, true);
  }catch(e){
    toast(e.message||String(e));
  }
}

/* Diagnostics */
async function runDiagnostics(){
  const month = $("#month").value;
  $("#diagMonth").textContent = month;
  const debts = await loadDebts();
  const tbody = $("#diagRows"); tbody.innerHTML = "";

  if(!debts.length){
    const tr=document.createElement("tr");
    tr.innerHTML=`<td colspan="7" class="bad">No debts in fin_debts_accounts.</td>`;
    tbody.appendChild(tr);
    return;
  }

  debts.forEach(d=>{
    const r = debtReady(d, month);
    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td>${esc(d.name||"(unnamed)")}${d.lender? ` <span class="small">— ${esc(d.lender)}</span>`:""}</td>
      <td>${r.min? money(r.min):'<span class="bad">—</span>'}</td>
      <td>${r.dueDay||'<span class="bad">—</span>'}</td>
      <td>${r.acctName? esc(r.acctName):'<span class="bad">—</span>'}</td>
      <td>${r.date||"—"}</td>
      <td>${r.ok ? '<span class="good">Ready</span>' : `<span class="bad">${esc(r.reason||"Missing fields")}</span>`}</td>
      <td class="right">
        ${r.ok ? `<button class="btn" data-act="force" data-id="${d.id}">Create</button>` : ""}
      </td>`;
    tbody.appendChild(tr);
  });

  // wire Create buttons
  tbody.querySelectorAll("button[data-act='force']").forEach(b=>{
    b.onclick=()=>forceCreateOne(b.dataset.id);
  });
}

async function loadDebts(){
  // pull debts and include pay-from account name
  const dsnap = await getDocs(query(
    collection(db,"fin_debts_accounts"),
    where("owner","==",state.user.email)
  ));
  return dsnap.docs.map(d=>({id:d.id, ...d.data()}));
}

function debtReady(d, month){
  const min = num(d.min);
  const dueDay = num(d.dueDay);
  const acctId = (d.payFromAccountId || "").trim();
  const acctName = acctId ? (state.payFromMap[acctId] || "") : "";

  if(!min) return {ok:false, reason:"Min missing/0", min, dueDay, acctId, acctName};
  if(!dueDay) return {ok:false, reason:"Due day missing/0", min, dueDay, acctId, acctName};
  if(!acctId || !acctName) return {ok:false, reason:"Pay-from account missing/invalid", min, dueDay, acctId, acctName};

  const date = ymdFromMonthDay(month, dueDay);
  return {ok:true, min, dueDay, acctId, acctName, date};
}

async function forceCreateOne(debtId){
  try{
    const month = $("#month").value;
    const dsnap = await getDocs(query(
      collection(db,"fin_debts_accounts"),
      where("owner","==",state.user.email)
    ));
    const d = dsnap.docs.map(x=>({id:x.id, ...x.data()})).find(x=>x.id===debtId);
    if(!d){ toast("Debt not found.", false); return; }
    const r = debtReady(d, month);
    if(!r.ok){ toast(r.reason||"Not ready", false); return; }

    // check duplicate by debtAccountId for this month
    const tsnap = await getDocs(query(
      collection(db,"fin_txns"),
      where("owner","==",state.user.email),
      where("month","==",month)
    ));
    const dup = tsnap.docs.find(x=>{
      const t=x.data();
      return t.debtAccountId===d.id;
    });
    if(dup){ toast("Already exists for this month.", false); return; }

    const cat   = `Debt Min: ${d.name||"Account"}`;
    const notes = d.lender ? `Auto-generated min for ${d.lender}` : `Auto-generated min`;

    await addDoc(collection(db,"fin_txns"),{
      owner: state.user.email,
      type: "expense",
      date: r.date, month,
      accountId: r.acctId,
      accountIdTo: null,
      amount: r.min,
      category: cat,
      notes,
      cleared: false,
      debtAccountId: d.id,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
    await loadTxns();
    await runDiagnostics();
    toast("Created one debt minimum.", true);
  }catch(e){
    toast(e.message||String(e));
  }
}

/* Render list with Edit support */
function render(){
  const acctSel=$("#filterAcct").value;
  const status=$("#filterCleared").value;
  const txt=($("#search").value||"").toLowerCase();

  let data=state.txns.slice();
  if(acctSel!=="all"){
    data=data.filter(x=>{
      if(x.type==="transfer") return x.accountId===acctSel || x.accountIdTo===acctSel;
      return x.accountId===acctSel;
    });
  }
  if(status==="cleared") data=data.filter(x=>!!x.cleared);
  if(status==="uncleared") data=data.filter(x=>!x.cleared);
  if(txt){
    data=data.filter(x=>{
      const hay=[x.category,x.notes,acctName(x.accountId),acctName(x.accountIdTo)].map(s=>String(s||"").toLowerCase()).join(" ");
      return hay.includes(txt);
    });
  }

  $("#counts").textContent=`${data.length} shown · ${state.txns.length} total`;

  // Running balance per selected account
  let running=0;
  const acct = acctSel==="all" ? null : state.accts.find(a=>a.id===acctSel);
  if(acct){ running = Number(acct.startingBalance||0); }

  const tb=$("#rows"); tb.innerHTML="";
  data.forEach(tx=>{
    if(acct){
      if(tx.type==="income" && tx.accountId===acct.id) running += tx.amount;
      if(tx.type==="expense" && tx.accountId===acct.id) running -= tx.amount;
      if(tx.type==="transfer"){
        if(tx.accountId===acct.id) running -= tx.amount;
        if(tx.accountIdTo===acct.id) running += tx.amount;
      }
    }

    const cat = tx.type==="transfer"
      ? `Transfer: ${esc(acctName(tx.accountId)||"?")} → ${esc(acctName(tx.accountIdTo)||"?")}`
      : esc(tx.category||"");

    const amtSigned =
      (tx.type==="income" || (tx.type==="transfer" && acct && tx.accountIdTo===acct.id))
        ? tx.amount : -tx.amount;

    const tr=document.createElement("tr");
    tr.innerHTML=`
      <td>${tx.date}</td>
      <td>${tx.type}</td>
      <td>${esc(acctName(tx.accountId)||"")}${tx.type==="transfer" && acctSel==="all" ? ` → ${esc(acctName(tx.accountIdTo)||"")}`:""}</td>
      <td>${cat}</td>
      <td class="right">${money(amtSigned)}</td>
      <td>
        <label><input type="checkbox" data-act="clr" data-id="${tx.id}" ${tx.cleared?"checked":""}> Cleared</label>
      </td>
      <td>${esc(tx.notes||"")}</td>
      <td class="right">
        <button class="btn" data-act="edit" data-id="${tx.id}">Edit</button>
        <button class="btn danger" data-act="del" data-id="${tx.id}">Delete</button>
      </td>`;
    tb.appendChild(tr);
  });

  $("#running").textContent = acct? money(running) : "$0.00";

  tb.querySelectorAll("input[data-act='clr']").forEach(ch=>{
    ch.onchange=async()=>{ await updateDoc(doc(db,"fin_txns",ch.dataset.id),{cleared:ch.checked,updatedAt:serverTimestamp()}); };
  });
  tb.querySelectorAll("button[data-act='del']").forEach(b=>{
    b.onclick=async()=>{ if(!confirm("Delete transaction?"))return; await deleteDoc(doc(db,"fin_txns",b.dataset.id)); await loadTxns(); };
  });
  tb.querySelectorAll("button[data-act='edit']").forEach(b=>{
    b.onclick=()=>beginEdit(b.dataset.id);
  });
}

function beginEdit(id){
  const tx = state.txns.find(t=>t.id===id);
  if(!tx) return;
  state.editTxnId=id;
  $("#txTitle").textContent="Edit Transaction";
  $("#txSave").textContent="Update";
  $("#txCancelEdit").style.display="inline-block";

  $("#t_type").value = tx.type; toggleTransfer();
  $("#t_date").value = tx.date;
  $("#t_account").value = tx.accountId || "";
  $("#t_accountTo").value = tx.accountIdTo || "";
  $("#t_amount").value = String(tx.amount ?? "");
  $("#t_cat").value = tx.type==="transfer" ? "" : (tx.category||"");
  $("#t_notes").value = tx.notes||"";
  $("#t_cleared").checked = !!tx.cleared;

  document.getElementById("txCard").scrollIntoView({behavior:"smooth",block:"start"});
}

function acctName(id){ if(!id) return ""; const a=state.accts.find(x=>x.id===id); return a? a.name:""; }

function exportCsv(){
  const rows=[["Date","Type","Account","ToAccount","Amount","Category","Cleared","Notes","Month","Id"]];
  state.txns.forEach(t=>{
    rows.push([t.date,t.type,acctName(t.accountId)||"",acctName(t.accountIdTo)||"",t.amount,t.category||"",t.cleared?"Yes":"No",(t.notes||"").replace(/\n/g," "),t.month,t.id]);
  });
  const csv=rows.map(r=>r.map(c=>{const s=String(c??"");return /[",\n]/.test(s)?`"${s.replace(/"/g,'""')}"`:s;}).join(",")).join("\n");
  const blob=new Blob([csv],{type:"text/csv;charset=utf-8"}); const url=URL.createObjectURL(blob);
  const a=document.createElement("a"); a.href=url; a.download=`transactions_${$("#month").value}.csv`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
}

// init empty form
resetTxnForm();
</script>
</body>
</html>
